{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>IELTS AI Examiner</title>
    <style>
        /* --- Base Styles --- */
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; max-width: 800px; margin: 2rem auto; padding: 20px; background-color: #f7f9fc; color: #333; }
        h1 { text-align: center; color: #5a29e4; }
        h2 { border-bottom: 2px solid #5a29e4; padding-bottom: 5px; margin-top: 40px;}
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulseGlow { 0% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.2); } 50% { box-shadow: 0 0 20px rgba(40, 167, 69, 0.8); } 100% { box-shadow: 0 0 5px rgba(40, 167, 69, 0.2); } }
        .control-buttons { text-align: center; margin: 20px auto; }
        .control-buttons button { padding: 12px 25px; font-size: 18px; font-weight: bold; color: #fff; border: none; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, opacity 0.2s, box-shadow 0.3s; margin: 0 10px; }
        #start-test-button { background-color: #28a745; }
        #skip-timer-button { background-color: #ffc107; color: #333; }
        #finish-part2-button { background-color: #dc3545; }
        button:hover:not(:disabled) { opacity: 0.85; }
        button:disabled { background-color: #6c757d; cursor: not-allowed; opacity: 0.6; }
        .btn-cta { animation: pulseGlow 2s infinite; }
        #status-container { text-align: center; margin-bottom: 20px; padding: 10px; border-radius: 8px; font-size: 1.2em; font-weight: 500; transition: all 0.3s ease; }
        .status-initial { background-color: #eef2f7; color: #333; }
        .status-recording { background-color: #ffcccc; color: #cc0000; }
        .status-processing { background-color: #ffffe0; color: #808000; }
        .status-speaking { background-color: #e0e0ff; color: #000080; }
        .status-error { background-color: #ffe0e0; color: #800000; }
        .status-disconnected { background-color: #ddd; color: #666; }
        .status-ready { background-color: #d4edda; color: #155724; }
        #timer-display { text-align: center; font-size: 2.5em; font-weight: bold; color: #5a29e4; margin: 15px 0; height: 50px; line-height: 50px; }
        .log-container { background-color: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 20px; min-height: 300px; max-height: 400px; overflow-y: auto; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .log-entry { margin-bottom: 15px; animation: fadeIn 0.5s ease-out; }
        .log-entry strong { color: #5a29e4; }

        /* --- Feedback Section Styles --- */
        #feedback-container { margin-top: 20px; }
        #feedback-log { margin-top: 15px; }
        .feedback-dropdown { background-color: #fff; border: 1px solid #e5e7eb; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05); overflow: hidden; }
        .feedback-header { padding: 15px 20px; cursor: pointer; display: flex; justify-content: space-between; align-items: center; transition: background-color 0.2s ease; }
        .feedback-header:hover { background-color: #f9fafb; }
        .feedback-header.open .arrow { transform: rotate(180deg); }
        .feedback-header .original-text { font-weight: 600; font-size: 1.05em; color: #333; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 15px; }
        .feedback-header .arrow { transition: transform 0.3s ease; font-size: 1.2em; }
        .feedback-content { padding: 0 20px 20px; display: none; border-top: 1px solid #e5e7eb; }
        .band-toggle { margin: 15px 0; display: flex; gap: 10px; }
        .band-toggle button { padding: 8px 16px; font-size: 14px; font-weight: 500; border: 1px solid #d1d5db; background-color: #fff; color: #374151; border-radius: 6px; cursor: pointer; transition: all 0.2s ease; }
        .band-toggle button:hover { background-color: #f9fafb; border-color: #9ca3af; }
        .band-toggle button.active { background-color: #5a29e4; color: #fff; border-color: #5a29e4; }
        .enhanced-speech { display: none; padding: 15px; background-color: #f9fafb; border-radius: 6px; border: 1px solid #e5e7eb; }
        .enhanced-speech.active { display: block; }
        .enhanced-speech p { margin-top: 0; line-height: 1.6; font-size: 1.1em; }
        .diff-added { background-color: #d4edda; color: #155724; padding: 2px 4px; border-radius: 4px; text-decoration: none; }
        .diff-removed { background-color: #f8d7da; color: #721c24; padding: 2px 4px; border-radius: 4px; text-decoration: line-through; }
        .tts-controls { margin-top: 10px; display: flex; gap: 8px; }
        .tts-controls button { padding: 6px 12px; font-size: 14px; border-radius: 5px; border: 1px solid #d1d5db; cursor: pointer; }
        .tts-controls .play-btn { background-color: #28a745; color: white; border-color: #28a745; }
        .tts-controls .stop-btn { background-color: #dc3545; color: white; border-color: #dc3545; }

        /* --- Final Evaluation Styles --- */
        #final-evaluation-container { display: none; animation: fadeIn 0.5s ease-out; margin-top: 20px;}
        .evaluation-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin-top: 20px; }
        .evaluation-card { background-color: #fff; border-radius: 8px; box-shadow: 0 4px 6px rgba(0,0,0,0.07); padding: 20px; }
        .card-header { display: flex; align-items: center; justify-content: space-between; border-bottom: 1px solid #eee; padding-bottom: 15px; margin-bottom: 15px; }
        .card-header h3 { margin: 0; font-size: 1.2em; color: #333; }
        .score-badge { font-size: 1.2em; font-weight: bold; color: #fff; background-color: #5a29e4; padding: 5px 12px; border-radius: 15px; }
        .card-content h4 { font-size: 1em; color: #5a29e4; margin-top: 20px; margin-bottom: 10px; }
        .card-content ul { list-style-type: none; padding-left: 0; margin: 0; }
        .card-content li { position: relative; padding-left: 25px; margin-bottom: 10px; line-height: 1.5; }
        .card-content li::before { position: absolute; left: 0; top: 4px; font-family: "Arial", sans-serif; font-weight: bold; }
        .strengths-list li::before { content: '✔'; color: #28a745; }
        .improvements-list li::before { content: '✖'; color: #dc3545; }
        .overall-score-card { background: linear-gradient(135deg, #5a29e4, #7b4dff); color: white; text-align: center; padding: 25px; border-radius: 8px; margin-bottom: 20px; }
        .overall-score-card h3 { margin: 0 0 10px 0; font-size: 1.5em; }
        .overall-score-card p { font-size: 3em; font-weight: bold; margin: 0; }
    </style>
</head>
<body>
    <h1>&#127908; IELTS Speaking Mock Test AI</h1>

    <div id="test-in-progress-container">
        <div class="control-buttons">
            <button id="start-test-button">Start IELTS Test</button>
            <button id="skip-timer-button" style="display: none;">I'm Ready</button>
            <button id="finish-part2-button" style="display: none;">I'm Finished</button>
        </div>
        <div id="timer-display"></div>
        <div id="status-container">Welcome!</div>
    </div>

    <!-- This container will only be used during the test -->
    <div class="log-container" id="live-log-container">
        <div id="log"></div>
    </div>

    <!-- This container will hold the final report elements -->
    <div id="final-report-container"></div>

    <!-- This container holds feedback and will be moved into the report at the end -->
    <div id="feedback-container" style="display: none;">
        <h2 id="feedback-title">Real-time Feedback</h2>
        <div id="feedback-log"></div>
    </div>


    <script type="module">
        // --- DOM Element References ---
        const startTestBtn = document.getElementById('start-test-button');
        const skipTimerBtn = document.getElementById('skip-timer-button');
        const finishPart2Btn = document.getElementById('finish-part2-button');
        const statusEl = document.getElementById('status-container');
        const logEl = document.getElementById('log');
        const liveLogContainer = document.getElementById('live-log-container');
        const feedbackContainerEl = document.getElementById('feedback-container');
        const feedbackLogEl = document.getElementById('feedback-log');
        const feedbackTitleEl = document.getElementById('feedback-title');
        const finalReportContainer = document.getElementById('final-report-container');
        const testInProgressContainer = document.getElementById('test-in-progress-container');
        const timerEl = document.getElementById('timer-display');

        // --- State Variables ---
        let socket;
        let timerToStartOnFinish = null;
        let audioContext;
        let stream;
        let audioWorkletNode;
        let isStreaming = false;

        // --- UI Update Functions ---
        function updateStatus(text, className) {
            statusEl.textContent = text;
            statusEl.className = 'status-container ' + className;
        }

        function addToLog(speaker, text) {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<strong>${speaker}:</strong> ${text}`;
            logEl.prepend(entry);
        }

        function renderDiff(diffData) {
            if (!diffData || !Array.isArray(diffData)) { return 'Suggestion not available.'; }
            return diffData.map(part => {
                const className = part.type === 'added' ? 'diff-added' : part.type === 'removed' ? 'diff-removed' : '';
                return `<span class="${className}">${part.value}</span>`;
            }).join('');
        }

        function addFeedbackDropdown(originalText, enhancements) {
            feedbackContainerEl.style.display = 'block';
            const dropdown = document.createElement('div');
            dropdown.className = 'feedback-dropdown';
            const header = document.createElement('div');
            header.className = 'feedback-header';
            header.innerHTML = `<span class="original-text">Feedback for: "${originalText}"</span><span class="arrow">&#9660;</span>`;
            const content = document.createElement('div');
            content.className = 'feedback-content';
            header.onclick = () => {
                const isOpen = content.style.display === 'block';
                content.style.display = isOpen ? 'none' : 'block';
                header.classList.toggle('open', !isOpen);
            };
            const bandToggle = document.createElement('div');
            bandToggle.className = 'band-toggle';
            const bands = ['Band 7', 'Band 8', 'Band 9'];
            bands.forEach((band, index) => {
                const button = document.createElement('button');
                button.textContent = band;
                if (index === 0) button.classList.add('active');
                button.onclick = (e) => {
                    e.stopPropagation();
                    bandToggle.querySelectorAll('button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    content.querySelectorAll('.enhanced-speech').forEach(speech => speech.classList.remove('active'));
                    content.querySelector(`.enhanced-speech[data-band="${band}"]`).classList.add('active');
                    speechSynthesis.cancel();
                };
                bandToggle.appendChild(button);
            });
            content.appendChild(bandToggle);
            bands.forEach((band, index) => {
                const speechContainer = document.createElement('div');
                speechContainer.className = `enhanced-speech ${index === 0 ? 'active' : ''}`;
                speechContainer.dataset.band = band;
                const speechText = document.createElement('p');
                const diffHtml = renderDiff(enhancements[band].diff);
                speechText.innerHTML = diffHtml;
                const plainTextForTts = enhancements[band].text;
                const ttsControls = document.createElement('div');
                ttsControls.className = 'tts-controls';
                const playBtn = document.createElement('button');
                playBtn.textContent = '▶ Play';
                playBtn.className = 'play-btn';
                const stopBtn = document.createElement('button');
                stopBtn.textContent = '■ Stop';
                stopBtn.className = 'stop-btn';
                playBtn.onclick = (e) => {
                    e.stopPropagation();
                    speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(plainTextForTts);
                    speechSynthesis.speak(utterance);
                };
                stopBtn.onclick = (e) => {
                    e.stopPropagation();
                    speechSynthesis.cancel();
                };
                ttsControls.appendChild(playBtn);
                ttsControls.appendChild(stopBtn);
                speechContainer.appendChild(speechText);
                speechContainer.appendChild(ttsControls);
                content.appendChild(speechContainer);
            });
            dropdown.appendChild(header);
            dropdown.appendChild(content);
            feedbackLogEl.prepend(dropdown);
        }

        function displayFinalEvaluation(data) {
            // This function builds the HTML for the final report
            // and places it in the final report container.

            // 1. Build the Overall Score Card HTML
            const overallScoreHtml = `
                <div class="overall-score-card">
                    <h3>Overall Band Score</h3>
                    <p>${data.overall_band_score || 'N/A'}</p>
                </div>
            `;

            // 2. Build the Detailed Evaluation Grid HTML
            let evaluationGridHtml = '<h2>Detailed Evaluation</h2><div class="evaluation-grid">';
            if (data.sections && data.sections.length > 0) {
                data.sections.forEach(section => {
                    const strengthsHtml = Object.entries(section.strengths).map(([key, value]) => `<li><strong>${key}:</strong> ${value}</li>`).join('');
                    const improvementsHtml = Object.entries(section.improvements).map(([key, value]) => `<li><strong>${key}:</strong> ${value}</li>`).join('');
                    evaluationGridHtml += `
                        <div class="evaluation-card">
                            <div class="card-header">
                                <h3>${section.title}</h3>
                                <span class="score-badge">${section.score}</span>
                            </div>
                            <div class="card-content">
                                <h4>Strengths</h4>
                                <ul class="strengths-list">${strengthsHtml}</ul>
                                <h4>Areas for Improvement</h4>
                                <ul class="improvements-list">${improvementsHtml}</ul>
                            </div>
                        </div>
                    `;
                });
            }
            evaluationGridHtml += '</div>';

            // 3. Assemble the final evaluation section
            const finalEvaluationSection = document.createElement('div');
            finalEvaluationSection.innerHTML = overallScoreHtml + evaluationGridHtml;

            // 4. Append to the main report container
            finalReportContainer.appendChild(finalEvaluationSection);
        }

        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function updateUiForState(state) {
            const allButtons = [startTestBtn, skipTimerBtn, finishPart2Btn];
            allButtons.forEach(btn => { btn.style.display = 'none'; btn.disabled = true; btn.classList.remove('btn-cta'); });

            switch(state) {
                case 'INITIAL':
                    startTestBtn.style.display = 'inline-block'; startTestBtn.disabled = false; startTestBtn.classList.add('btn-cta');
                    updateStatus('Click "Start IELTS Test" to begin.', 'status-initial');
                    break;
                case 'CONNECTING':
                    startTestBtn.style.display = 'inline-block';
                    updateStatus('Connecting and setting up microphone...', 'status-processing');
                    break;
                case 'WAITING_FOR_AI': updateStatus('AI is speaking...', 'status-speaking'); isStreaming = false; break;
                case 'READY_TO_LISTEN': updateStatus('Your turn. Start speaking whenever you\'re ready.', 'status-ready'); isStreaming = true; break;
                case 'PROCESSING': updateStatus('Processing your response...', 'status-processing'); isStreaming = false; break;
                case 'PREP_TIME':
                    skipTimerBtn.style.display = 'inline-block'; skipTimerBtn.disabled = false; skipTimerBtn.classList.add('btn-cta');
                    updateStatus('You have 1 minute to prepare your notes.', 'status-processing'); isStreaming = false;
                    break;
                case 'SPEAK_TIME':
                    finishPart2Btn.style.display = 'inline-block'; finishPart2Btn.disabled = false; finishPart2Btn.classList.add('btn-cta');
                    updateStatus('Your 2 minutes of speaking time has started.', 'status-recording'); isStreaming = true;
                    break;
                case 'ENDED':
                    // This is where the final page layout is constructed.
                    // 1. Hide the in-progress elements
                    testInProgressContainer.style.display = 'none';

                    // 2. Change the main page title
                    document.querySelector('h1').textContent = 'Your IELTS Mock Test Report';

                    // 3. Append the Enhanced Speech Feedback to the report
                    if (feedbackLogEl.childElementCount > 0) {
                        feedbackTitleEl.textContent = 'Enhanced Speech Feedback';
                        finalReportContainer.appendChild(feedbackContainerEl);
                    }

                    // 4. Create a title for the transcript and append the log
                    const transcriptTitle = document.createElement('h2');
                    transcriptTitle.textContent = 'Full Conversation Transcript';
                    finalReportContainer.appendChild(transcriptTitle);
                    finalReportContainer.appendChild(liveLogContainer); // Move the chat log to the end

                    // 5. Final status update
                    updateStatus('Test Concluded. Your full report is shown below.', 'status-speaking');
                    testInProgressContainer.appendChild(statusEl); // Move status to be visible
                    isStreaming = false;
                    break;
                case 'ERROR': startTestBtn.style.display = 'inline-block'; startTestBtn.disabled = false; isStreaming = false; break;
            }
        }

        const audioProcessor = `
            class AudioStreamer extends AudioWorkletProcessor {
                process(inputs, outputs, parameters) {
                    const input = inputs[0];
                    if (input.length > 0) { this.port.postMessage(this.floatTo16BitPCM(input[0])); }
                    return true;
                }
                floatTo16BitPCM(input) {
                    const output = new Int16Array(input.length);
                    for (let i = 0; i < input.length; i++) {
                        const s = Math.max(-1, Math.min(1, input[i]));
                        output[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    return output;
                }
            }
            registerProcessor('audio-streamer', AudioStreamer);
        `;

        function stopAudio() {
            if (stream) { stream.getTracks().forEach(track => track.stop()); stream = null; }
            if (audioContext && audioContext.state !== 'closed') { audioContext.close().catch(e => console.error("Error closing AudioContext:", e)); audioContext = null; }
        }

        async function setupAudioStreaming() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 });
                stream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 16000, channelCount: 1 } });
                const source = audioContext.createMediaStreamSource(stream);
                const blob = new Blob([audioProcessor], { type: 'application/javascript' });
                const url = URL.createObjectURL(blob);
                await audioContext.audioWorklet.addModule(url);
                audioWorkletNode = new AudioWorkletNode(audioContext, 'audio-streamer');
                source.connect(audioWorkletNode);
                audioWorkletNode.connect(audioContext.destination);
                audioWorkletNode.port.onmessage = (event) => {
                    if (isStreaming && socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(event.data.buffer);
                    }
                };
                return true;
            } catch (e) {
                console.error("FRONTEND LOG: Failed to initialize audio streaming:", e);
                updateStatus('Error: Could not access microphone. Please grant permission and try again.', 'status-error');
                updateUiForState('ERROR');
                return false;
            }
        }

        function setupWebSocket() {
            const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
            socket = new WebSocket(wsScheme + '://' + window.location.host + '/ws/speech/');
            socket.onopen = async () => {
                const audioReady = await setupAudioStreaming();
                if (audioReady) updateUiForState('WAITING_FOR_AI');
            };
            socket.onclose = () => {
                stopAudio();
                updateStatus('Disconnected. Please refresh to start again.', 'status-disconnected');
            };
            socket.onerror = (error) => {
                console.error("WebSocket Error:", error);
                updateStatus('Connection Error. Check console and backend logs, then try again.', 'status-error');
                updateUiForState('ERROR');
            };
            socket.onmessage = (event) => {
                if (event.data instanceof Blob) {
                    const audio = new Audio(URL.createObjectURL(event.data));
                    audio.play();
                    updateUiForState('WAITING_FOR_AI');
                    audio.onended = () => {
                        if (timerToStartOnFinish) {
                            socket.send(JSON.stringify({ type: "tts_finished" }));
                            timerToStartOnFinish = null;
                        } else if (statusEl.className.includes('status-speaking')) {
                            socket.send(JSON.stringify({ type: "start_streaming" }));
                            updateUiForState('READY_TO_LISTEN');
                        }
                    };
                } else {
                    const data = JSON.parse(event.data);
                    switch (data.type) {
                        case 'user_transcript':
                            addToLog('You', data.text);
                            updateUiForState('PROCESSING');
                            break;
                        case 'speech_enhancement':
                            addFeedbackDropdown(data.original_text, data.enhancements);
                            break;
                        case 'ai_response':
                            addToLog('Examiner', data.text);
                            timerToStartOnFinish = data.start_timer_on_finish || null;
                            break;
                        case 'final_evaluation':
                            displayFinalEvaluation(data.evaluation); // Populates the report container
                            updateUiForState('ENDED');              // Arranges the final page layout
                            stopAudio();
                            break;
                        case 'timer_update':
                            timerEl.textContent = formatTime(data.remaining);
                            if (data.timer_type === 'prep_timer') updateUiForState('PREP_TIME');
                            else if (data.timer_type === 'speak_timer') updateUiForState('SPEAK_TIME');
                            break;
                        case 'timer_end':
                            timerEl.textContent = '';
                            skipTimerBtn.style.display = 'none';
                            finishPart2Btn.style.display = 'none';
                            break;
                        case 'force_stop_streaming':
                            isStreaming = false;
                            break;
                    }
                }
            };
        }

        // --- Event Listeners ---
        startTestBtn.onclick = () => {
            updateUiForState('CONNECTING');
            setupWebSocket();
        };
        skipTimerBtn.onclick = () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: "skip_prep_timer" }));
                timerEl.textContent = '';
                updateUiForState('PROCESSING');
            }
        };
        finishPart2Btn.onclick = () => {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: "finish_part_2" }));
                updateUiForState('PROCESSING'); // <-- Corrected typo here
            }
        };

        // --- Initial State ---
        updateUiForState('INITIAL');
    </script>
</body>
</html>